---
title: 
date: 
categories: 
tags: 
mathjax: true
description: 
---

## Reference

一个操作系统的实现

## Intro



## 需求实现

### 老师需求



### 额外完成



## 技术难点

### 利用时间中断来调度进程

因为需要时间片轮转, 或者需要依据优先级给进程划分不同的时间片, 所以很自然地想到我们需要将调度函数插入到时钟中断中. 

### 回顾中断流程

1. CPU在执行当前指令后检查是否有中断

2. 根据中断号在IDT中取得处理该中断的段选择符

3. 根据取得的段选择符到GDT中找到段描述符

4. 根据特权级判断是否发生栈切换, 如果发生, 则需要从tss中取出内核栈地址, 并立即切换到内核栈, 立即压旧的`ss`, `esp`

5. 保护现场, 压入`eflags`, `cs`, `eip`. 如果是有错误码的异常, 则需要压入`errorCode`

6. 跳转到中断服务程序的第一条指令开始执行

7. 在中断程序的末尾, 需要更新`TSS`的内核栈位置

    ```asm
    	mov	esp, [p_proc_ready]             ; 取出保存寄存器的位置
    	lldt	[esp + P_LDT_SEL]           ; 加载ldt
    	lea	eax, [esp + P_STACKTOP]         ; 取出刚进入中断的内核栈esp位置
    	mov	dword [tss + TSS3_S_SP0], eax   ; 暂存esp
    ```

    这里有个小`trick`, 就是在进程刚进入中断处理程序时, `save`操作同时将已经更新为内核栈的`esp`也保存, 所以可以在中断末尾的时候借用这个`esp`还原. 
    但是这带来一个问题, 第一个进程刚启动之前, 需要做一些准备, 当然实现上也很简单

    ```asm
    
    ```

    

8. 处理完毕后, 使用`iret`或`iretd`返回先前的用户程序, CPU会从栈弹出(`ss`, `esp`)`eflags`, `cs`, `eip`.特别需要注意的是, CPU不会处理`errorCode`, 所以此前需要额外考虑是否需要弹出`errorCode`

那么我们就知道实现是很简单的了, 只需要修改`p_proc_ready`, 在中断前后将进程的上下文保存在`PCB`中的特定的位置, 从中恢复. 